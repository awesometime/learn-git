[Sliding Window](https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247485197&idx=1&sn=1bbd40d49adb09875fd324664bd5bc8b&chksm=fa0e688ccd79e19a36599b53e4a8acf9a725ace3f6df28925075ff25778238471a283f0f8e1f&mpshare=1&scene=1&srcid=&pass_ticket=j3%2FFn1LGmNyOmO1IavFA9HkU%2Fr77JJ9Ld1p4l3mOrd%2B8YdPgI7VbX2hnqg2YVka8#rd)
```
# 建立一个256位大小的整型数组 freg ，用来建立字符和其出现位置之间的映射。
#
# 维护一个滑动窗口，窗口内的都是没有重复的字符，去尽可能的扩大窗口的大小，窗口不停的向右滑动。
#
# （1）如果当前遍历到的字符从未出现过，那么直接扩大右边界；
#
# （2）如果当前遍历到的字符出现过，则缩小窗口（左边索引向右移动），然后继续观察当前遍历到的字符；
#
# （3）重复（1）（2），直到左边索引无法再移动；
#
# （4）维护一个结果res，每次用出现过的窗口大小来更新结果 res，最后返回 res 获取结果。
```

### 模板
```python3
class Solution:
    def lengthOfLongestSubstring(self, s):
        lookup = collections.defaultdict(int)
        l, r, counter, res = 0, 0, 0, 0
        while r < len(s):
            lookup[s[r]] += 1
            if lookup[s[r]] == 1:
                counter += 1
            r += 1
            # counter < r - l 说明有重复字符出现，正常为counter == r - l
            while l < r and counter < r - l:
                lookup[s[l]] -= 1
                if lookup[s[l]] == 0:
                    counter -= 1
                l += 1
            res = max(res, r - l)
        return res
```

```python3
def lengthOfLongestSubstring(s):
    freq = [0] * 256
    left = 0
    right = 0  # 滑动窗口为s[left...right]
    res = 0

    while left < len(s) and right < len(s):
        if right < len(s) and freq[ord(s[right])] == 0:
            freq[ord(s[right])] += 1
            right += 1
        else:                                        # right已经到头 or freq[ord(s[right+1])] == 1
            freq[ord(s[left])] -= 1
            left += 1
        res = max(res, right - left)
        # print(str(left) + ' | ' + str(right) + ' | ' + str(freq[97:110])+ ' | ' + str(res))
    return res
    
# ASCII码转换为int：ord('A')    65
# int转为ASCII码：chr(65)   'A'

def lengthOfLongestSubstring(s):
    if not s or len(s) == 0:
        return 0

    l, r = 0, 0
    res, lookup = 0, set()
    while l < len(s) and r < len(s):
        if s[r] not in lookup:
            lookup.add(s[r])
            res = max(res, r - l + 1)
            r += 1
        else:
            lookup.discard(s[l])
            l += 1
        # print(l, r, lookup)
    return res
```
