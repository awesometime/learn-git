> DFS 实现排列算法A(n,n)  加剪枝去重

```python3
# DFS 实现排列算法A(n,n)  剪枝去重
# https://leetcode.com/problems/permutations-ii/discuss/18649/Python-easy-to-understand-backtracking-solution.
def permuteUnique(nums):
    res = []
    nums.sort()
    dfs1(nums, [], res)
    return res

def dfs1(nums, path, res):
    # print('-------传入-------')
    # print('nums' + str(nums))
    # print('path' + str(path))
    # print('res ' + str(res))
    if not nums:                                   # append into res after fetch all digital from nums
        res.append(path)
        # print('res append  ' + str(res))
    for i in range(len(nums)):
        # 字符串有重复 剪枝
        if i > 0 and nums[i] == nums[i - 1]:       # i=0 是第一种,i > 0从第二个开始只要等于第一个就continue
            continue                               # 已经排序了 所以相同元素一定相邻
        dfs1(nums[:i] + nums[i + 1:], path + [nums[i]], res)       # nums[:i] + nums[i + 1:] == nums[i]的补集,保证nums中所有数字都取到

nums1 = [5,8,8]
print(permuteUnique(nums1))
```
### 剑指offer

好理解

```python3
class Solution:
    def Permutation(self, ss):
        # write code here
        if not ss:
            return []
        if len(ss) == 1:
            return list(ss)
        
        charList = list(ss)
        charList.sort()
        pStr = []
        for i in range(0,len(charList)):
            if i > 0 and charList[i] == charList[i-1]:    # 字符串有重复的时候剪枝
                continue
            temp = self.Permutation(''.join(charList[:i])+''.join(charList[i+1:]))
            for j in temp:
                pStr.append(charList[i] + j)
                
        return pStr
```

不推荐

字符的全排列过程可以这样描述：

    挑选出所有可以放在第一位的字符，也就是把第一个字符与剩余部分每个字符交换一次。

    求 除第一个字符外的所有字符的全排列

https://www.nowcoder.com/questionTerminal/fe6b651b66ae47d7acce78ffdd9a96c7

```python3
https://blog.csdn.net/qq_20141867/article/details/80933497
class Solution:
    def Permutation(self, ss):
        # write code here
        out = []
        if len(ss) == 0:
            return out
        charlist = list(ss)
        # charList.sort()
        self.permutation(charlist, 0, out)
        out = [''.join(out[i]) for i in range(len(out))]
        out.sort()    
        return out

    def permutation(self, ss, begin, out):
        if begin == len(ss)-1:
            out.append(ss[:])
        else:
            for i in range(begin, len(ss)):
                # 如果是重复字符，跳过
                # 这里ss没有先排序  所以用begin != i判断  而不是ss[i] == ss[i-1]
                if ss[begin] == ss[i] and begin != i:
                    continue
                else:
                    # 依次与后面每个字符交换
                    ss[begin], ss[i] = ss[i], ss[begin]
                    self.permutation(ss, begin + 1, out)
                    # 回到上一个状态
                    ss[begin], ss[i] = ss[i], ss[begin]
                    
                    
#  swap(begin,i)|    --> begin(0,len-1)     -->i(begin,len-1)
#
#                                                                        abcd(状态A)
#                                                 |                                             \
#                                                 |swap(0,0)                                     \swap(0,1)   swap(0,2)  swap(0,3)
#                                                 |                                               \
#                                          abcd(状态B)                                           bacd(状态B)      cbad     dbca
#                          /                    |                 \                               ...              ...     ...
#         swap(1,1)     /                      |swap(1,2)           \ swap(1,3)
#                     /                       |                      \
#               abcd                        acbd                       adcb
#     swap(2,2) /  \swap(2,3)    swap(2,2) /  \swap(2,3)     swap(2,2) /  \swap(2,3)
#              /    \                     /    \                      /    \
#          abcd    abdc                acbd      acdb                 adcb     adbc
#  swap(3,3) /      \swap(3,3) swap(3,3) /       \swap(3,3)  swap(3,3) /      \swap(3,3)
#          abcd    abdc                acbd      acdb                 adcb     adbc
```
