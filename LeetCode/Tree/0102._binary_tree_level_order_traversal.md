**Python solutions: DFS recursively, DFS with stack, BFS with queue.**

```py3
# DFS recursively
def levelOrder1(self, root):
    res = []
    self.dfs(root, 0, res)
    return res
    
def dfs(self, root, level, res):
    if not root:
        return 
    if len(res) < level+1:
        res.append([])
    res[level].append(root.val)
    self.dfs(root.left, level+1, res)
    self.dfs(root.right, level+1, res)
 
# DFS + stack I   
def levelOrder2(self, root):
    if not root:
        return []
    res, stack = [], [(root, 0)]
    while stack:
        curr, level = stack.pop()
        if len(res) < level + 1:
            res.append([])
        res[level].append(curr.val)
        if curr.right:
            stack.append((curr.right, level+1))
        if curr.left:
            stack.append((curr.left, level+1))
    return res


# DFS + stack II  
def levelOrder3(self, root):
    res, stack = [], [(root, 0)]
    while stack:
        curr, level = stack.pop()
        if curr:
            if len(res) < level + 1:
                res.append([])
            res[level].append(curr.val)
            stack.append((curr.right, level+1))
            stack.append((curr.left, level+1))
    return res

# BFS + queue
def levelOrder4(self, root):
    res, queue = [], [(root, 0)]
    while queue:
        curr, level = queue.pop(0)
        if curr:
            if len(res) < level+1:
                res.append([])
            res[level].append(curr.val)
            queue.append((curr.left, level+1))
            queue.append((curr.right, level+1))
    return res
    
# BFS + deque
def levelOrder(self, root):
    from collections import deque
    res, queue = [], deque([(root, 0)])
    while queue:
        curr, level = queue.popleft()
        if curr:
            if len(res) < level+1:
                res.append([])
            res[level].append(curr.val)
            queue.append((curr.left, level+1))
            queue.append((curr.right, level+1))
    return res
```


### 先想到了迭代


```python3
class Solution(object):
    def levelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        if not root:
            return []
        res, cur_level = [], [root]
        while cur_level:
            next_level, temp_res = [], []
            for node in cur_level:
                temp_res.append(node.val)
                if node.left:
                    next_level.append(node.left)
                if node.right:
                    next_level.append(node.right)
            res.append(temp_res)
            cur_level = next_level
        return res
```


### 递归


```python3
class Solution:
    def levelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        def dfs(node, level, res):
            if not node:
                return
            if len(res) < level:
                res.append([])               # 每次先append [] 否则报错 list index out of range
            res[level-1].append(node.val)    # 在每一层res[level-1] 去append
            dfs(node.left, level+1, res)
            dfs(node.right, level+1, res)  
                
        res = []
        dfs(root, 1, res)
        return res
```

```python3
import random
res = []
for i in range(5):
    if len(res) < i+1:
        res.append([])
    for j in range(i):    # 一般另起一个名字叫j,   i容易乱套
        res[i].append(random.randint(1,10))
print(res)
# [[], [2], [1, 10], [3, 4, 5], [6, 6, 8, 5]]
```
