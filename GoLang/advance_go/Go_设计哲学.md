### Go 的动态类型

https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/11.12.md

在经典的面向对象语言（像 C++，Java 和 C#）中数据和方法被封装为 类 的概念：类包含它们两者，并且不能剥离。

Go 没有类：数据（结构体或更一般的类型）和方法是一种松耦合的正交关系。

Go 中的接口跟 Java/C# 类似：都是必须提供一个指定方法集的实现。但是更加灵活通用：任何提供了接口方法实现代码的类型都隐式地实现了该接口，而不用显式地声明。

和其它语言相比，Go 是唯一结合了接口值，**静态类型检查（是否该类型实现了某个接口）**，运行时动态转换的语言，并且不需要显式地声明类型是否满足某个接口。该特性允许我们在不改变已有的代码的情况下定义和使用新接口。


**Go 的动态类型**

**接收一个（或多个）接口类型作为参数的函数，其实参可以是任何实现了该接口的类型的变量。 实现了某个接口的类型可以被传给任何以此接口为参数的函数 。**

静态(编译时期)类型检查 底层具体是怎么做的??? 

Go通常需要编译器静态检查的支持：当变量被赋值给一个接口类型的变量时，编译器会检查其是否实现了该接口的所有函数。如果方法调用作用于像 interface{} 这样的“泛型”上，你可以通过类型断言（参见 11.3 节）来检查变量是否实现了相应接口。

因此 Go 提供了动态语言的优点，却没有其他动态语言在运行时可能发生错误的缺点。

### 函数重载

https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/11.12.md

在 6.1 节中, 我们看到函数重载是不被允许的。

在 Go 语言中函数重载可以用可变参数 ...T 作为函数最后一个参数来实现（参见 6.3 节）。如果我们把 T 换为空接口，那么可以知道任何类型的变量都是满足 T (空接口）类型的，这样就允许我们传递任何数量任何类型的参数给函数，即重载的实际含义。

函数 fmt.Printf 就是这样做的：

fmt.Printf(format string, a ...interface{}) (n int, errno error)

### 接口继承

https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/11.12.md
