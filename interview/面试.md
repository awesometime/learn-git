### 1 Python中的装饰器

Python中的装饰器其实也是一种函数， 它可以在不修改原函数代码情况下扩展原函数功能。装饰器函数与普通函数不同之处就在于装饰器函数返回了一个函数对象，装饰器利用了闭包的原理来实现。主要用于日志插入，权限管理等等。

### 多进程和多线程 python协程

> 1 并发 并行

并发实质是一个物理CPU（也可以是多个物理CPU）在若干个程序之间多路复用
单核CPU执行并发多任务 ，操作系统轮流让各个任务交替执行

并行多个cpu同时执行多个任务
真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也
会自动把很多任务轮流调度到每个核心上执行。真正地同时执行多线程需要多核CPU才可能实现。

实现并发的方式有多种：比如多进程、多线程、IO多路复用，协程

> 2 进程

```
进程就是操作系统中一段程序的执行过程，是操作系统分配资源（CPU、内存等）基本单位，它是程序执行时
的一个实例(体)。程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程
调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。每一个进程（执行的程序）都有自己对应的
系统分配的内存地址，分为几个段
  数据段：全局变量
  代码段：处理器执行的代码
  堆：存放进程运行中被动态分配的内存段，它的大小并不固定
  栈：执行过程调用的指令和局部变量
进程共有三种状态：就绪、阻塞和运行


多进程进程上下文切换需要消耗较多资源 
数据共享与进程间通信 Queue，Value,Array ，Pipe用于管道通信， Manager用于资源共享 
同步子进程模块：Condition，Event，Lock，RLock，Semaphore

启动多进程的方法
  启动一个子进程并等待其结束 
  创建一个类继承Process类，并重写run方法 
  进程池
  
Unix/Linux操作系统提供了一个fork()系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，
但是fork()调用一次，返回两次，因为操作系统自动把当前进程(称为父进程)复制了一份(称为子进程)，
然后，分别在父进程和子进程内返回。
```

> 3 线程
```
线程是程序执行时的最小cpu调度单位。如何调度进程和线程，完全由操作系统决定。线程是操作系统调度的最小单元。
结构    线程ID、程序计数器、寄存器集合和堆栈
一个进程可以由很多个线程组成，线程间共享进程的所有资源，
每个线程有自己的堆栈和局部变量。线程由CPU独立调度执行，在多CPU环境下就允许多个线程同时刻运行。
线程切换需要先保存当前执行的现场环境（CPU寄存器状态、内存页等）


多线程可以同时运行多个任务，多个线程共同访问同一片数据，则由于数据访问的顺序不一样，有可能导致
数据结果不一致的问题，需要相互通信和协调
一个线程，比如"set"，要访问共享数据时，必须先获得锁定。如果已经有别的线程获得锁定了，比如"print"，
那么就让线程"set"暂停，也就是同步阻塞。等到线程"print"访问完毕，释放锁之后，再让线程"set"继续


多线程通信
1 共享全局变量（不安全一般不用）2 queue
不同线程间数据共享的方法就是使用消息队列queue
一个ThreadLocal变量虽然是全局变量，但每个线程都只能读写自己线程的独立副本，互不干扰。
ThreadLocal解决了参数在一个线程中各个函数之间互相传递的问题

多线程同步
1 锁Lock、RLock可重入锁   2 条件变量(condition) 3 控制进入数量的锁Semaphore类
3的例子写文件的时候，一般只用于一个线程写；读文件的时候可以用多个线程读，我们可以用信号量来控制多少个线程读文件


Python中多线程由于有GIL的影响， 导致在任何时刻仅有一个线程在执行
即便在多核心处理器上，使用 GIL 的解释器也只允许同一时间执行一个线程
适合在 IO 密集型操作(读写数据操作较多的，比如爬虫)会把锁释放


启动多线程方法
1 启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始执行
2 通过继承Thread类重写run方法创建新线程
3 ThreadPoolExecutor线程池

threading模块提供的类：
Thread，Lock，Rlock，Condition，[Bounded] Semaphore，Event，Timer，local。
```

> 4.1 协程
```
一个线程里面可以有多个协程
线程和进程的操作是由程序触发系统接口，最后的执行者是系统；协程的操作则是程序员。
是比线程（thread）更细量级的用户态线程，特点是允许用户的主动调用和主动退出，挂起当前的
例程然后返回值或去执行其他任务，接着返回原来停下的点继续执行。
我们把一个线程中一个个函数叫做子程序，那么子程序在执行过程中可以中断去执行别的子程序；
别的子程序也可以中断回来继续执行之前的子程序，这就是协程


专业的理解 
协程拥有自己的寄存器上下文和栈
协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器
上下文和栈。因此：协程能保留上一次调用时的状态(即所有局部状态的一个特定组合)，每次过程
重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。


优势
1 协程极高的执行效率  由程序自身控制，因此，没有线程切换的开销
2 第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程
中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。

协程是一个线程执行，那么怎么利用多核CPU呢？
最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。

协程存在的意义：
对于多线程应用，CPU通过切片的方式来切换线程间的执行，线程切换时需要耗时（保存状态，下次
继续）。协程，则只使用一个线程，在一个线程中规定某个代码块执行顺序。

协程的适用场景：
当程序中存在大量不需要CPU的操作时(IO)，适用于协程。

Python通过yield提供了对协程的基本支持
事件循环 future对象 task对象
yield  send
@asyncio.coroutine  yield from
async await
```
> 4.2 协程

协程是程序级别的，由程序员根据需要自己调度。我们把一个线程中的一个个函数叫做子程序，那么子程序在执行过程中可以
中断去执行别的子程序；别的子程序也可以中断回来继续执行之前的子程序，这就是协程。

Python中协程最初使用yield来实现， 当程序运行到yield语句时就会将控制权交出来去执行其他的函数， 

在Python3   之前只能通过原生yield、greenlet以及Gevent第三方库来实现协程， 
在Python3   之后引入了yield from， yield from 用于重构生成器。
在Python3.5 之后引用了async和await， 其作为yield from， yield的完美替身来实现协程。

就不同语言中面向并发设计的协程实现而言，Scala 与 Erlang 的 Actor 模型、Golang 中的 goroutine 都较 Python 更为成熟，

不同的协程使用通信来共享内存，优化了竞态、冲突、不一致性等问题。然而，根本的理念没有区别，都是在**用户态**通过**事件循环**驱动实现调度。

> 生成器的进化

yield 关键字被加入到语法中，下一次从生成器中取值可以恢复到生成器上次 yield 执行的位置。

在 Python2.5 中生成器还加入了 send 方法，与 yield 搭配使用。

生成器不仅仅可以 yield 暂停到一个状态，还可以往它停止的位置通过 send 方法传入一个值改变其状态。

yield from 实现了在生成器内调用另外生成器的功能  在生成器中从其他生成器 yield 一个值，这样不同的生成器之间可以互相通信

每个协程都拥有独立的寄存器上下文和栈空间，即使它们是都工作在同一个线程中的。

```
线程和进程各自有什么区别和优劣呢？

1 
进程是资源分配的最小单位，线程是程序执行的最小单位。

2 内存
进程有自己的独立内存地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、
堆栈段和数据段，进程切换需要的资源最大，

线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同
时创建一个线程的开销也比进程要小很多。

3 通信
线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，

进程之间的通信需要以通信的方式（IPC)进行。一个子进程崩溃并不会影响其他子进程和主进程的运行，
最大的优点就是稳定性高

4
多进程适合在 CPU 密集型操作(cpu 操作指令比较多，如位数多的浮点运算)。
多线程适合在 IO 密集型操作(读写数据操作较多的，比如爬虫)
```

### 3 Python的垃圾回收机制以及内存管理

垃圾回收机制：
Python的垃圾回收机制以引用计数为主， 标记清除、分代回收为辅。

1 引用计数指：
Python在内部维护了针对每一个对象的引用计数，
当一个对象创建或者被引用时，其引用计数将加1，当一个对象被销毁或作用域失效时， 其引用计数将减1。只有对象的引用计数为0时，
这个对象将会被回收。引用计数的优点：简单、具有实时性。
缺点：对象循环引用时将永远不会被销毁。对于对象循环引用的状况

2 Python使用标记清除来解决，Python在内部实现了一个循环检测器， 不停的检测对象是否存在循环引用，如果两个对象互相循环引用
并且不包含其他第三者对象时， 其将会被收回。在Python参考手册中有写道：当一个对象无法获取时， 那么这个对象有可能被当成垃
圾销毁了。

3 Python将所有对象分成了三代， 对象存活时间越长就越晚被回收， 反之则越早被回收。


内存管理：内存池机制
http://images.cnitblog.com/blog/333250/201410/110017426714010.x-png

Python使用了内存池机制来管理内存，其内存以金字塔的形式对内存功能进行划分，
-1、-2层主要用于对操作系统进行操作， 
0层中是C的malloc,、free等等内存分配和释放函数。
1、2层是一个内存池， 当对象小于265K时将直接由这片内存池进行分配内存，否则将调用第0层中的C函数来分配内存，当小于265K的对象
被销毁时， 其内存也不会被销毁， 只是返回给了内存池以便二次利用。2层是对Python对象进行操作。


Python的内存机制以金字塔行，-1，-2层主要有操作系统进行操作，
第0层是C中的malloc，free等内存分配和释放函数进行操作；
第1层和第2层是内存池，有Python的接口函数PyMem_Malloc函数实现，当对象小于256K时有该层直接分配内存；
第3层是最上层，也就是我们对Python对象的直接操作；

在 C 中如果频繁的调用 malloc 与 free 时,是会产生性能问题的.再加上频繁的分配与释放小块的内存会产生内存碎片. 
Python 在这里主要干的工作有:
如果请求分配的内存在1~256字节之间就使用自己的内存管理系统,否则直接使用 malloc.
这里还是会调用 malloc 分配内存,但每次会分配一块大小为256k的大块内存.
经由内存池登记的内存到最后还是会回收到内存池,并不会调用 C 的 free 释放掉.以便下次使用

### 4 IaaS PaaS SaaS

IaaS 是云服务的最底层，提供硬件基础设施部署服务，主要提供实体或虚拟的计算、存储和网络等资源。它与 PaaS 的区别是，用户需要自己控制底层，实现基础设施的使用逻辑。

PaaS 提供软件部署平台（runtime），是云计算应用程序运行环境，提供应用程序部署与管理服务，抽象掉了硬件和操作系统细节，可以无缝地扩展（scaling）。开发者只需要关注自己的业务逻辑，不需要关注底层

SaaS 是软件的开发、管理、部署都交给第三方，不需要关心技术问题，可以拿来即用。普通用户接触到的互联网服务，几乎都是 SaaS

### docker

Docker公司推出的三剑客：Machine、Compose和Swarm。

docker-machine：解决Docker运行环境问题。 Docker技术是基于Linux内核的cgroup技术实现的

dcoker-compose：解决本地Docker容器编排问题。 一般是通过yaml配置文件来使用它，这个docker-compose.yml文件里能记录多个容器启动的配置信息（镜像、启动命令、端口映射等），最后只需要执行docker-compose对应的命令，例如docker-compose up就会像执行脚本一样地批量创建和销毁容器。

docker-swarm：解决多主机多个容器调度部署得问题。 Swarm是基于Docker平台实现的集群技术，他可以通过几条简单的指令快速的创建一个Docker集群，接着在集群的共享网络上部署应用，最终实现分布式的服务。Swarm技术不是很成熟，目前更多的是使用Kubernetes来管理集群和调度容器。

### os、sys模块不同

os、sys模块不同，并列举常用的模块方法

os: 提供了对使用操作系统函数的高度封装
sys: 提供由解释器访问或者维护的变量以及与解释器交互的一些函数

os模块只负责程序与操作系统交互， 提供了访问操作系统底层的接口封装。
sys模块负责程序与解释器交互， 提供了一系列的函数用于操控Python运行的环境设置。
https://zhuanlan.zhihu.com/p/38226619

### 切片是浅拷贝

Python中拷贝分为深拷贝、浅拷贝。浅拷贝只拷贝父级对象， 不会拷贝对象内部的子对象，使用copy模块中的copy。深拷贝则会完全拷贝父对象以及子对象， 使用copy模块中的deepcopy。

### IO多路复用
