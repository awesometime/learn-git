"""
并发    一个时间段内 有几个程序在同一个cpu上运行 任意时刻只有一个程序在cpu上运行
并行    任意时刻 有多个程序同时运行在多个cpu上运行


针对消息通信机制
同步    代码调用IO操作时 等待IO操作完成才返回的调用方式
异步    代码调用IO操作时 不必等待IO操作完成就返回的调用方式  返回一个Future


针对函数调用
阻塞    调用函数是当前线程被挂起
非阻塞  调用函数是当前线程不会被挂起 立即返回


-----------------------------------------
UNIX I/O模型
1  阻塞式I/O
2  非阻塞式I/O                       不用select只能实现监听一个socket/文件句柄，可以简单理解为只能为一个任务服务
3  I/O复用（使用最多成熟）            select、poll(windows)、epoll(linux)  可以同时服务多个任务
4  信号驱动式I/O（不用看）
5  异步I/O （不如I/O复用成熟）        posix的aio_系列函数
-----------------------------------------
补充
3  I/O复用（使用最多成熟）
   select poll epoll 本质同步阻塞式I/O
   在非阻塞式基础上用select可以同时去监听多个socket/文件句柄请求，一旦就绪就通知
   select功能: 返回可读的或准备好的socket/文件句柄
   数据可读就通知app去进行处理,需要app自己去将数据从内核读到用户空间
5 异步I/O
   操作系统将数据从内核缓存读到用户缓存后才通知app去进行处理


-------------------------------------------
挑战
1 回调模式编程复杂
2 同步模式并发性不高
3 多线程需要线程同步 lock

解决  *引入协程
1 采用同步方法去编写异步代码
2 采用单线程 + 具体cpu、io操作逻辑用协程调度   【协程是单线程模式】
   多线程间切换由操作系统完成 单线程由我们自己去调度任务
   不需要锁  并发性高 单线程内切换函数性能高于线程间切换
"""