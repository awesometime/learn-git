- [9700 star Python的面试点](https://github.com/taizilongxu/interview_python)
- [100 python 面试题](https://blog.csdn.net/weixin_41666747/article/details/79942847)

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*



   * [Python基础知识](#python基础知识)
      * [0 Python所有的内置函数](#0-Python所有的内置函数)
      * [1 yield函数](#1-yield函数)
      * [2 Python中的反射 getattr hasattr setattr delattr](#2-python中的反射-getattr-hasattr-setattr-delattr)
      * [3 sys.stdout sys.stdin sys.stderr](#3-sys.stdout-sys.stdin-sys.stderr)
      * [4 sys.argv](#4-sys.argv)
      * [5 locals nonlocal globals global 递归](#5-locals-nonlocal-globals-global-递归)
      * [6 break continue](#6-break-continue)
      * [7 str repr](#7-str-repr)
      * [8 and or](#8-and-or)
      * [9 arg kwarg](#9-arg-kwarg)
      * [10 修饰符 装饰器 闭包](#10-修饰符-装饰器-闭包)
      * [11 函数 类方法 实例方法](#11-函数-类方法-实例方法)
      * [12 赋值引用 浅拷贝 深拷贝 切片](#12-赋值引用-浅拷贝-深拷贝-切片)
      * [13 字符 编码与二进制  序列化](#13-字符-编码与二进制--序列化)
      * [14 try except](#14-try-except)
      * [15 new init super 方法](#15-new-init-super-方法)
      * [16 单双下划线](#16-单双下划线)
      * [17 yeild iterator](#17-yeild-iterator)
      * [18 readline readlines](#18-readline-readlines)
      * [19 callback](#19-callback)
      * [20 list sort sorted](#20-list-sort-sorted)
      * [21 re正则表达式](#21-re正则表达式)
      * [22 python垃圾回收机制](#22-python垃圾回收机制)
      * [23 lambda](#23-lambda)
      * [24 python传参数是传址 引用](#24-python传参数是传址-引用)
      * [25 if not](#25-if-not)
      * [26 name main](#26-name-main)
      * [27 classmethod staticmethod](#27-classmethod-staticmethod)
      * [28 abstract class](#28-abstract-class)
      * [29 函数参数有冒号 声明后有箭头](#29-函数参数有冒号-声明后有箭头)
      * [30 unittest assert](#30-unittest-assert)
      * [31 双下划线开头的函数和变量 内置方法 魔法方法](#31-双下划线开头的函数和变量-内置方法-魔法方法)
      * [32 hook method](#32-hook-method)
      * [33 last,now=now,max(last+num,now)](#33-last,now=now,max(last+num,now))
      * [34 reduce](#34-reduce)
      * [35 Daemon](#35-Daemon)
         * [1 使用__new__方法](#1-使用__new__方法)
         * [2 共享属性](#2-共享属性)
         * [3 装饰器版本](#3-装饰器版本)
         * [4 import方法](#4-import方法)


## Python基础知识

### 0 Python所有的内置函数

[Python所有的内置函数](https://www.cnblogs.com/hongfei/p/3858256.html)


### 1 yield函数

- [  yield 理解 ](https://blog.csdn.net/Ren_ger/article/details/81088903)
- [  yield用法总结  ](https://www.cnblogs.com/python-life/articles/4549996.html)

```python
def fun(): # 只能迭代一次
    print('good')
    yield 5

# fun().__next__()  # 其实是依次实例化了3个不同的对象;   查id一样,是因为实例化第二个对象时第一个已经销毁
# fun().__next__()  
# fun().__next__()  # 所以不会抛异常

# good
# good
# good

# 这样调用
f = fun()  # 这句不会执行print('good')语句
print(f.__next__())
# f.__next__()  # 第二次由于之后没有yield,再次next()就会抛出错误
print("---")
try:
    print(f.__next__())
except StopIteration as e:
    print("StopIteration")

# good
# 5
# ---
# StopIteration
```

```python
# 0. 遇到yield就返回 相当于return,  a.__next__()返回值为yield表达式的参数
# 1. a.__next__(此处不可有参数)相当于a.send(None) 即yield xxx ==None
# 2. a.send("msg") 即yield xxx == value
# 4. 第一次迭代时，必须用__next__()语句或是send(None)，即yield xxx ==None ,不能使用send发送一个非None的值，否则会出错的
# 【5】. a.send(None)、a.send("msg") 和 a.__next__() 、next(a)是有返回值的，它们的返回值很特殊，
#        返回的是下一个yield表达式的参数。比如yield 5，则返回 5     a 是一个generator object
# 【6】. yield xxx 返回send("msg")中的msg
# 7. send("msg") 和 __next__() 的作用 记住上次执行完的位置（状态）
###
# 【注意区别yield xxx和xxx】:
# yield xxx 的值是 None 并非xxx, 除非a.send("msg") 则yield xxx == msg  （这个其实没啥用一般）
# yield xxx 中的 xxx 是__next__()或者send("msg")的返回值（也就是我们常用到的）


def fun():
    for i in range(20):
        x = yield i        #表达式(yield i)的返回值将赋值给x  i作为__next__()的返回值
        print(x)
        print('good', x)   # 疑问 ？ yield完 最后一次的print 如何执行打印


a = fun()   # 运行fun()
print(a)    # <generator object fun at 0x000002720919B258>
print(a.__next__()) # 第一次迭代时，i=0,遇到yield直接终止,并返回yield表达式的参数0
print("---")
print(a.__next__())   # 从上次离开的地方先执行内部fun()函数,再返回yield表达式的参数

print("---")
l = a.send(5)         # (yield i) 表达式被赋予了 5 ,即 x = (yield i) = 5
print(l)              # 但是 a.send(5) 返回的是下一个yield表达式的参数 ,此处为2

print("---")
print(a.send(5))

print("---")
print(a.send("life is short,you need python"))


# 0
# ---
# None       # 函数内的结果
# good None  # 函数内的结果
# 1          # print(a.__next__())的结果
# ---
# 5
# good 5
# 2          # print(a.__next__())的结果
# ---
# 5
# good 5
# 3
# ---
# life is short,you need python
# good life is short,you need python
# 4
```

```python
import time
def func(n):
    for i in range(0, n):
        arg = yield i
        print('func:', arg)


f = func(10)
while True:
    print('next:', next(f))
    print('send:', f.send(100))
    time.sleep(1)

# 输出
# next: 0
# func: 100
# send: 1
# func: None
# next: 2
# func: 100
# send: 3
# func: None
# next: 4
# func: 100
# send: 5
# func: None
# next: 6
# func: 100
# send: 7
# func: None
# next: 8
# func: 100
# send: 9
# func: None
# Traceback (most recent call last):
#   File "F:/Python/projects/yield.py", line 73, in <module>
#     print('next:', next(f))
# StopIteration

```

### 2 Python中的反射 getattr hasattr setattr delattr

- 反射  getattr hasattr setattr delattr

基于反射实现类Web框架的路由系统 [详见79行](https://github.com/awesometime/CMDB/blob/master/assets/asset_handler.py)
 

```python
class Foo(object):
 
    def __init__(self):
        self.name = 'abc'
 
    def func(self):
        return 'func--函数运行ok'
 
obj = Foo()

# 1 获取成员
# 判断ｏｂｊ中是否有第二个参数
# 如果第二个是属性，则返回属性值，如果是方法名，则返回方法的内存地址，如果第二个参数没有在对象中找到，程序报错

ret = getattr(obj, 'func')          # 获取的是个对象，返回ｆｕｎｃ的内存地址
print(ret)                          # <bound method Foo.func of <__main__.Foo object at 0x000002D08D42E7B8>>
r = ret()                           # 需要将对象实例化
print(r)                            # func--函数运行ok

ret1 = getattr(obj, 'name')         # 返回字符串
print(ret1)                         # abc


# 2 检查成员
ret = hasattr(obj,'func')            # 因为有func方法所以返回True
print(ret)                           # True


# 3 设置成员
print(obj.name)                      # abc
ret = setattr(obj,'name',19)
print(obj.name)                      # 19


# 4 删除成员属性
print(obj.name)                      # 19
delattr(obj,'name')
print(obj.name)                      # 报错

```
```python
#!/usr/bin/env python
#coding=utf-8
__author__ = 'lx'

#1.py           注意  1.py 2.py 在同一目录下
class Foo:
    def __init__(self,name):
        temp = "xxx"
        self.name = name
 
    def show(self):
        print('show wo')
        
#!/usr/bin/env python
#coding=utf-8
__author__ = 'lx'

#2.py
#导入模块
print('0')
m = __import__("1",fromlist=True)
print(m)

#去模块中找类
class_name = getattr(m,"Foo")
print(class_name)
#根据类创建对象
obj = class_name("Yj")
print(obj)
#去对象中找方法
ret = getattr(obj,'show')
print('1')
r = ret()
print(r)

#去对象中找name对应的值
print('2')
val = getattr(obj,'name')
print('3')
print(val)

结果
0
<module '1' from 'C:/Users/li/Desktop\\1.py'>
<class '1.Foo'>
<1.Foo object at 0x000001BD3AEDDB00>
1
show wo
None
2
3
Yj

```

### 3 sys.stdout sys.stdin sys.stderr


```python
# 在python中调用print时，事实上调用了sys.stdout.write(obj+'\n')
# print 将需要的内容打印到控制台，然后追加一个换行符
# 以下两行代码等价：

sys.stdout.write('hello' + '\n')
print('hello')

# sys.stdin与input

import sys
h1 = input()               # lin
h2 = sys.stdin.readline()  # lin
print(len(h1))  # 3
print(len(h2))  # 4

# sys.stdin.readline( )会将标准输入全部获取，包括末尾的'\n'，因此用len计算长度时是把换行符'\n'算进去了的，
# 但是input( )获取输入时返回的结果是不包含末尾的换行符'\n'的。

# 因此如果在平时使用sys.stdin.readline( )获取输入的话，不要忘了去掉末尾的换行符，可以用strip( )函数
#（sys.stdin.readline( ).strip('\n')）或sys.stdin.readline( )[:-1]这两种方法去掉换行。

```
```python
import sys
import time

############
name = input("Please input your name: ")
print(name)
input = sys.stdin.readline()
print(input)

############
print("some str")
sys.stdout.write('some str\n')

# \r 能实现重置到行首吗
for i in range(5):
    sys.stdout.write('\r'+ str(i) +'\n')
    # print("\r"+str(i))
    sys.stdout.flush()
    time.sleep(1)

############
# 红色显示
print("critical error\n", file=sys.stderr)  # Python 3
sys.stderr.write('sf\n')
sys.stdout.write('xf')
```

### 4 sys.argv

[参考Python中 sys.argv[]的用法简明解释](http://www.cnblogs.com/aland-1415/p/6613449.html)

[Pycharm的传参 像cmd中执行一样 python 1.py arg1 arg2](http://www.mamicode.com/info-detail-2053390.html)

Run“ ---  "Edit Configurations" --- "Script parameters"  参数之间用空格隔开
```python
# 假如 G:/PyCharm/PythonProjects/cmdb/Client/bin下有一个main.py文件，里面有a_func b_func 方法
# main.py
if __name__ == '__main__':
    handler.ArgvHandler(sys.argv)
def a_func():
   pass
def b_func():
   pass  
print(sys.argv)
for i in range(len(sys.argv)):
    print(sys.argv[i])

# 在G:/PyCharm/PythonProjects/cmdb/Client/bin/执行 
G:/PyCharm/PythonProjects/cmdb/Client/bin>main.py a_func b_func
['main.py', 'a_func', 'b_func', 't', 't', 'u', 'i', 'gik']
main.py
a_func
b_func
t
t
u
i
gik
```
```python
class ArgvHandler(object):  # 继承

    def __init__(self, args):  
        self.args = args
        self.parse_args()

    def parse_args(self):
        """
        分析参数，如果有参数指定的功能，则执行该功能，如果没有，打印帮助说明。
        :return:
        """
        if len(self.args) > 1 and hasattr(self, self.args[1]):
            func = getattr(self, self.args[1])
            func()
        else:
            self.b_func()
# G:/PyCharm/PythonProjects/cmdb/Client/bin>main.py a_func b_func
# 就会把a_func b_func当参数传给 self.args
```

### 5 locals nonlocal globals global 递归

 参考 https://yq.aliyun.com/ziliao/114421
```python3
# nonlocal 适用于在局部函数中调用局部函数的局部变量， 把最内层的局部变量设置成外层局部可用，但是还不是全局的
# nonlocal是Pythoh 3出现的关键字
# nonlocal可以使得内部函数修改外部函数中的变量
# Python 2中，内部函数可以读取外部函数中的变量，但不能修改
# nonlocal关键字只能用于嵌套函数中，并且外部函数中定义了相应的局部变量，否则会发生错误

# 对于一个全局变量，函数里如果只使用到了它的值，而没有对其赋值（指a = XXX这种写法）的话，就不需要声明global。
# 相反，如果你对其赋了值的话，那么你就需要声明global

# 全局一层  scope_test一层  do_local一层   三层
def scope_test():
    def do_local():
        spam = "local spam"      #  此函数定义了另外的一个spam字符串变量，并且生命周期只在此函数内。此处的spam和外层的spam是两个变量，如果写出spam = spam + “local spam” 会报错
    def do_nonlocal():
        nonlocal  spam           # 其它函数或作用域内可以调用这里申明的spam变量
        spam = "nonlocal spam"
    def do_global():
        global spam
        spam = "global spam"    # global全局变量在函数体内或者作用域内不可调用，仅可在全局调用
	print('in do_global():   '+spam)

    spam = "test spam"
    do_local()
    print("After local assignmane:", spam)
    do_nonlocal()
    print("After nonlocal assignment:",spam)
    do_global()
    print("After global assignment:",spam)

scope_test()
print("In global scope:",spam)
print("spam = %s " % spam)


#outputs: 
After local assignmane: test spam           # 私有变量在函数外不可调用，故spam依旧是test spam
After nonlocal assignment: nonlocal spam    # scope_test()函数体内调用的spam是nonlocal spam
in do_global():   global spam
After global assignment: nonlocal spam      # scope_test()函数体内调用的spam是nonlocal spam
In global scope: global spam                # 跳出scope_test()函数之外，为全局变量故spam是global spam
spam = global spam                          # 外边没定义 但可以打印？
```
```python
# 汉诺塔  递归  画树形分支图有助于理解递归次数统计
def moveTower(height, fromPole, toPole, withPole):
    if height >= 1:
        moveTower(height - 1, fromPole, withPole, toPole)
        moveDisk(fromPole, toPole)
        moveTower(height - 1, withPole, toPole, fromPole)

def moveDisk(fp, tp):
    global i
    i += 1
    print(str(i) + " moving disk from", fp, "to", tp)


i = 0
moveTower(4, "1", "2", "3")
print(i)
```

```python
# 递归 recursion 画树形分支图有助于理解递归次数统计
def outer(num):
    global recursion_count
    recursion_count += 1
    if num > 0:
        outer(num - 1)
        # count += 1
        inner()
        outer(num - 1)

print_count = 0
recursion_count = 0

def inner():
    global print_count
    print_count += 1
    print(str(print_count) + "th  :)")


outer(3)
print("print_count  " + str(print_count))   # 统计移动次数
print("recursion_count  " + str(recursion_count))   # 统计递归次数
# recursion_count = 2 * print_count + 1

# 1th  :)
# 2th  :)
# 3th  :)
# 4th  :)
# 5th  :)
# 6th  :)
# 7th  :)
# print_count  7    # 2的n次-1
# recursion_count  15
```

```python
# 画树形分支图有助于理解递归次数统计
def func(num):
    global count
    count += 1
    if num <= 3:
        return 1
    else:
        return func(num - 4) + func(num - 2) + 1

# 统计递归次数
count = 0
print(func(func(8)))
print(count)
```

### 6 break continue

```python
#1   循环语句可以有一个 else 子句;
#    当（for）循环迭代完整个列表或（while）循环条件变为假，而非由break语句终止时，就会执行这个else语句
#    循环中的else子句  与   try语句的else子句有更多的共同点：   try语句的else子句在未出现异常时运行
for n in range(2, 10):
...     for x in range(2, n):
...         if n % x == 0:
...             print(n, 'equals', x, '*', n//x)
...             break
...     else:
...         # loop fell through without finding a factor
...         print(n, 'is a prime number')
...     
...     print('333')

break  跳出for...else...  到 print('333')

#2
for num in range(2, 10):
...     if num % 2 == 0:
...         print("Found an even number", num)
...         continue
...     print("Found a number", num)
print('333')
continue  跳出for 到下一次循环！！！    而不是print('333')

```
### 7 str repr
```python
#  __repr__和__str__这两个方法都是用于显示的，__str__是面向用户的，而__repr__面向程序员
class A(object):
    def __str__(self):
	    return 'this is A'   # 用print输出具体的信息；用t为对象

class B(object):
	pass
	    
class C(object):	
	def __repr__(self):
	    return 'this is A'        # 用print用t输出具体的信息

t = [A(),B(),C()]	

print(t)
# [<__main__.A object at 0x0000022149C58390>, <__main__.B object at 0x0000022149CB2B38>, this is A]

print(t[0])
print(t[1])
print(t[2])

# this is A      str  printt[0]时候才会显示
# <__main__.B object at 0x0000022149CB2B38>
# this is A      repr  任何时候都打印显示
```

### 8 and or

and:    遇假则假，所以前面为假就不执行和判断后面，前面为真则继续判断执行后面的;

or:     遇真则真，所以前面为真就不执行和判断后面，前面为假则继续判断执行后面的。

### 9 arg kwarg

*arg        任意个位置/形式参数     不加 * 为一个

**kwarg      任意个关键词参数  

https://www.jianshu.com/p/e0d4705e8293




### 10 修饰符 装饰器 闭包

装饰符(修饰符)@类似于 [回调函数](https://www.zhihu.com/question/19801131)，把其它的函数（暂且称为目的函数）作为自己的入参，在目的函数执行前，执行一些自己的操作，

比如：计数、打印一些提示信息等，然后返回目的函数。

装饰器只会被调用一次。只在 Python 导入脚本的时候运行。

[一份来自 StackOverflow 的最佳 Python 装饰器教程](https://mp.weixin.qq.com/s/KCXkOCIMzIp86tU-OJuZMg)

[python中闭包和装饰器的理解（关于python中闭包和装饰器解释最好的文章）](https://www.cnblogs.com/3me-linux/p/6761635.html)

[看完这篇文章还不懂Python中的闭包，请拍死小编](https://baijiahao.baidu.com/s?id=1601023189180094497&wfr=spider&for=pc)

[较好理解  如何理解Python装饰器？刘志军](https://www.zhihu.com/question/26930016)

[较全面    万字长文深度解析Python装饰器](https://zhuanlan.zhihu.com/p/53837833?utm_source=wechat_session&utm_medium=social&utm_oi=631526660110028800)

> 函数执行
```python3
def a():
    def b():
        def c():
            print("c")
            return 'c-3'
        print("b")
        return c()
    print('a')
    return b()
s = a()
print(s)
# a
# b
# c
# c-3

# -------------
def a():
    def b():
        def c():
            print("c")
            return 'c-3'

        print("b")
        return c

    print('a')
    return b
s1 = a()
print(s1)
# a
# <function a.<locals>.b at 0x00000000028996A8>
s = a()()()
print(s)
# a
# b
# c
# c-3


# -------------
def a():
    def b():
        def c():
            print("c")
        c()
        print("b")
    b()
    print('a')
    return b

s = a()
print(s)
# c
# b
# a
# <function a.<locals>.b at 0x0000000002BB96A8>
```

> 一切皆对象
```python3
def hi(name="yasoob"):
    return "hi " + name

print(hi())
# output: 'hi yasoob'

# 我们甚至可以将一个函数赋值给一个变量，比如
greet = hi
# 我们这里没有在使用小括号，因为我们并不是在调用hi函数
# 而是在将它放在greet变量里头。我们尝试运行下这个

print(greet())
# output: 'hi yasoob'

# 如果我们删掉旧的hi函数，看看会发生什么！
del hi
print(hi())
#outputs: NameError

print(greet())
#outputs: 'hi yasoob'



from functools import wraps

def a_new_decorator(a_func):
    @wraps(a_func)
    def wrapTheFunction():
        print("I am doing some boring work before executing a_func()")
        a_func()
        print("I am doing some boring work after executing a_func()")

    return wrapTheFunction


@a_new_decorator
def a_function_requiring_decoration():
    """Hey you! Decorate me!"""
    print("I am the function which needs some decoration to "
          "remove my foul smell")


a_function_requiring_decoration()
print(a_function_requiring_decoration.__name__)
```


```python3
def my_decorator(func):
    print('I am an ordinary function')

    def wrapper():
        print('I am function returned by the decorator')
        func()

    return wrapper


def lazy_function():
    print('zzzzzzzz')


my_decorator(lazy_function)()
# lazy_function = my_decorator(lazy_function)
# lazy_function()
```


```python3
def my_decorator(func):
    print('I am an ordinary function')

    def wrapper():
        print('I am function returned by the decorator')
        func()

    return wrapper


@my_decorator
def lazy_function():
    print('zzzzzzzz')


lazy_function()   #不等于my_decorator(lazy_function)() 这种在没有@my_decorator时才等价
# 注意即使不执行lazy_function() 也会输出 print('I am an ordinary function')这句


# my_decorator(lazy_function)()  # 错误用法  有@my_decorator时 不能这样用了
# 执行顺序   待进一步学习  可以和下边的一段代码一起看

```

```python3
def decorator_maker():
    print('I make decorators! I am executed only once: ' +
          'when you make me create a decorator.')

    def my_decorator(func):
        print('I am a decorator! I am executed only when you decorate a function.')

        def wrapped():
            print('I am the wrapper around the decorated function. '
                  'I am called when you call the decorated function. '
                  'As the wrapper, I return the RESULT of the decorated function.')
            return func()

        print('As the decorator, I return the wrapped function.')

        return wrapped

    print('As a decorator maker, I return a decorator')
    return my_decorator


# 让我们创建一个装饰器。本质上是一个新函数
new_decorator = decorator_maker()


# outputs:
# I make decorators! I am executed only once: when you make me create a decorator.
# As a decorator maker, I return a decorator

# 然后我们装饰下面这个函数

def decorated_function():
    print('I am the decorated function.')


decorated_function = new_decorator(decorated_function)
# outputs:
# I am a decorator! I am executed only when you decorate a function.
# As the decorator, I return the wrapped function


# 调用这个函数
decorated_function()
# outputs:
# I am the wrapper around the decorated function. I am called when you call the decorated function.
# As the wrapper, I return the RESULT of the decorated function.
# I am the decorated function.


# decorator_maker()(decorated_function)()      等价于这样

```


```python3
import time

def time(func):     # 传入啥 返回啥  中间执行自己的小动作
    print(time.ctime())
    return func()    # 
    
@time  # 从这里可以看出@time 等价于 time(xxx()),但是这种写法你得考虑python代码的执行顺序
def xxx():
    print('Hello world!')

运行结果：
Wed Jul 26 23:01:21 2017
Hello world!

```

```python3
def benchmark(func):
    """
    一个用来输出函数执行时间的装饰器
    """
    import time
    def wrapper(*args, **kwargs):
        t = time.clock()
        res = func(*args, **kwargs)
        print func.__name__, time.clock()-t
        return res
    return wrapper
 
 
def logging(func):
    """
    一个用来记录脚本活动的装饰器。
    （实际上只是打印出来，但可以输出到日志！）
    """
    def wrapper(*args, **kwargs):
        res = func(*args, **kwargs)
        print func.__name__, args, kwargs
        return res
    return wrapper
 
 
def counter(func):
    """
    一个用来统计并输出函数执行次数的装饰器
    """
    def wrapper(*args, **kwargs):
        wrapper.count = wrapper.count + 1
        res = func(*args, **kwargs)
        print '{0} has been used: {1}x'.format(func.__name__, wrapper.count)
        return res
    wrapper.count = 0
    return wrapper
 
@counter
@benchmark
@logging
def reverse_string(string):
    return str(reversed(string))
 
print reverse_string('Able was I ere I saw Elba')
print reverse_string('A man, a plan, a canoe, pasta, heros, rajahs, a coloratura, maps, snipe, percale, macaroni, a gag, a banana bag, a tan, a tag, a banana bag again (or a camel), a crepe, pins, Spam, a rut, a Rolo, cash, a jar, sore hats, a peon, a canal: Panama!')
 
#outputs:
#reverse_string ('Able was I ere I saw Elba',) {}
#wrapper 0.0
#wrapper has been used: 1x 
#ablE was I ere I saw elbA
#reverse_string ('A man, a plan, a canoe, pasta, heros, rajahs, a coloratura, maps, snipe, percale, macaroni, a gag, a banana bag, a tan, a tag, a banana bag again (or a camel), a crepe, pins, Spam, a rut, a Rolo, cash, a jar, sore hats, a peon, a canal: Panama!',) {}
#wrapper 0.0
#wrapper has been used: 2x
#!amanaP :lanac a ,noep a ,stah eros ,raj a ,hsac ,oloR a ,tur a ,mapS ,snip ,eperc a ,)lemac a ro( niaga gab ananab a ,gat a ,nat a ,gab ananab a ,gag a ,inoracam ,elacrep ,epins ,spam ,arutaroloc a ,shajar ,soreh ,atsap ,eonac a ,nalp a ,nam A
```
### 11 函数 类方法 实例方法
```python
def aa(d, na=None, *kasd, **kassd):
    pass
class A(object):
    def f(self):
        return 1
a = A()
print '#### 各自方法描述 ####'
print '## 函数     %s' % aa
print '## 类方法   %s' % A.f
print '## 实例方法 %s' % a.f

#### 各自方法描述 ####
## 函数   <function aa at 0x000000000262AB38>
## 类方法   <unbound method A.f>
## 实例方法 <bound method A.f of <__main__.A object at 0x0000000002633198>>
```

### 12 赋值引用 浅拷贝 深拷贝 切片

赋值引用   两个 a，b 指向同一对象 同时改变

浅拷贝    父对象（一级层面）是一个独立的对象，但是他们的子对象（内部 可理解为二级层面）还是指向同一对象，所以子对象会随着 a 的改变而改变

深拷贝    两个 a，b 两者是完全独立的

应用： 列表  **字典

[参考](http://www.cnblogs.com/wushuaishuai/p/7737917.html)
[浅深拷贝](https://mp.weixin.qq.com/s?__biz=MzU2MTU3ODI2Nw==&mid=2247484054&idx=1&sn=de9abaf2f2b0b712bdda77dc351debf4&chksm=fc77eae2cb0063f4a8a8e4ff6d57af2462cb8cfd0420558cb5e89d86df1c51f063571fab4b4d&scene=0&subscene=131&clicktime=1556159416&ascene=7&devicetype=android-28&version=27000436&nettype=WIFI&abtest_cookie=BAABAAoACwASABMABQAjlx4AVpkeAL%2BZHgDUmR4A3JkeAAAA&lang=zh_CN&pass_ticket=UQjoYaZPtiGRRzXqkVQ0vuL5FZNrD2Yyog313%2BPUi2NE9CuF83XNkfi4vXg4RM8D&wx_header=1)

```python
import copy
a = [1, 2, 3, 4, ['a', 'b']] #原始对象
  
b = a                       #赋值，传对象的引用
c = copy.copy(a)            #对象拷贝，浅拷贝
d = copy.deepcopy(a)        #对象拷贝，深拷贝
  
a.append(5)                 #修改对象a
a[4].append('c')            #修改对象a中的['a', 'b']数组对象
  
print( 'a = ', a )
print( 'b = ', b )
print( 'c = ', c )
print( 'd = ', d )

#
('a = ', [1, 2, 3, 4, ['a', 'b', 'c'], 5])
('b = ', [1, 2, 3, 4, ['a', 'b', 'c'], 5])
('c = ', [1, 2, 3, 4, ['a', 'b', 'c']])
('d = ', [1, 2, 3, 4, ['a', 'b']])
```
```
a = [1, 2, [3, 4, 5]]
b = a[:]
# a[0]=100
a[2][0] = 19
print(id(a[0]))
print(b)
print(id(1))

# a = [id(1), id(2), id([3, 4, 5])]
# a = [id(1), id(2), id(列表)]
# a = [id(1), id(2), id([id(3), id(4), id(5)])]
# b = a[:]
# b = [id(1), id(2), id([id(3), id(4), id(5)])]
# a[0]=100
# a = [id(100), id(2), id([id(3), id(4), id(5)])]
# a[2][0] = 19
# a = [id(100), id(2), id([id(19), id(4), id(5)])]
# b = [id(1), id(2), id([id(19), id(4), id(5)])]

```

### 13 字符 编码与二进制  序列化

[字符、编码与二进制——序列化](https://mp.weixin.qq.com/s/7tQIKpwH4J4djCM3l5pDnQ)


### 14 try except
[try except (异常捕获)](https://www.cnblogs.com/Keep-Ambition/p/7306074.html)

### 15 new init super 方法
**new init**
```
1、__new__至少要有一个参数cls，代表当前类，此参数在实例化时由Python解释器自动识别

2、__new__必须要有返回值，返回实例化出来的实例，这点在自己实现__new__时要特别注意，可以return父类（通过super(当前类名, cls)）__new__出来的实例，或者直接是object的__new__出来的实例

3、__init__有一个参数self，就是这个__new__返回的实例，__init__在__new__的基础上可以完成一些其它初始化的动作，__init__不需要返回值

4、如果__new__创建的是当前类的实例，会自动调用__init__函数，通过return语句里面调用的__new__函数的第一个参数是cls来保证是当前类实例，
如果是其他类的类名，(  ????? 找个例子  )；那么实际创建返回的就是其他类的实例，其实就不会调用当前类的__init__函数，也不会调用其他类的__init__函数。

```

```python
class A(object):
    def __init__(self):
        print("init function invoked", self)

    def __new__(cls):
        print("cls  id", id(cls))
        print("new function invoked", object.__new__(cls))
        return object.__new__(cls)


a = A()
print("A  id", id(A))
b = A()

# cls  id 2722172060296
# new function  <__main__.A object at 0x00000279D00D8438>
# init function <__main__.A object at 0x00000279D00D8438>
# A  id 2722172060296
# cls  id 2722172060296
# new function  <__main__.A object at 0x00000279D00D8358>
# init function <__main__.A object at 0x00000279D00D8358>
```


[Python类与对象实例详解](https://www.imooc.com/article/18018?block_id=tuijian_wz)

定义类IntTuple继承tuple,并实现new,修改实例化行为
先执行new  再执行init
new方法接受的参数虽然也是和init一样，但init是在类实例创建之后调用，而 new方法正是创建这个类实例的方法。new方法会返回所构造的对象，init则不会，在使用new返回对象的时候会隐式调用init函数。new函数必须以cls作为第一个参数，而init则以self作为其第一个参数

```python
class IntTuple(tuple):
    def __new__(cls, iterable):
        # 重写父类  new 方法 以满足自己需求
 	g = (x for x in iterable if isinstance(x,int) and x > 0)
        print(cls)
        # return super(IntTuple, cls).__new__(cls, g)
        return super().__new__(cls, g)   # 可省略  必须return
        # return tuple().__new__(cls, g)
        
	# 必须return init 才能接收到创建的实例
	# 调用父类的__new__方法
        # 找到IntTuple的父类（tuple），然后把 类IntTuple 的 类对象cls 转换为 类tuple 的对象，然后转换后的 类tuple对象 调用自己的__new__方法
	
    def __init__(self, iterable):
        print(self)
        # super(IntTuple,self).__init__()
	super().__init__()
        # 找到IntTuple的父类（tuple），然后把 类IntTuple 的 对象self 转换为 类tuple 的对象，然后“被转换”的 类tuple对象 调用自己的__init__方法
	
t = IntTuple([1,-1,'abc',6,['x','y'],3])
print t

# 输出：
<class '__main__.IntTuple'>
(1, 6, 3)
(1, 6, 3)
```
**super**
[super的使用详解](https://blog.csdn.net/brucewong0516/article/details/79121179)
```python
class Parent(object):
    Value = "Hi, Parent value"
    def fun(self):
        print("This is from Parent")

class Child(Parent):
    Value = "Hi, Child  value"
    def fun(self):
        print("This is from Child")
        Parent.fun(self)   #调用父类Parent的fun函数方法

c = Child()    
c.fun()

# This is from Child
# This is from Parent  #实例化子类Child的fun函数时，首先会打印上条的语句，再次调用父类的fun函数方法
```
```python
class Parent(object):
    Value = "Hi, Parent value"
    def fun(self):
        print("This is from Parent")

class Child(Parent):
    Value = "Hi, Child  value"
    def fun(self):
        print("This is from Child")
        #Parent.fun(self)
        super(Child,self).fun()  #相当于用super的方法与上一调用父类的语句置换

c = Child()    
c.fun()

# This is from Child
# This is from Parent  #实例化子类Child的fun函数时，首先会打印上条的语句，再次调用父类的fun函数方法

```
### 16 单双下划线
https://www.cnblogs.com/hester/articles/4936603.html
```python
#主要存在四种情形

object # public
__object__   # special, python system use, user should not define like it
__object     # private (私有变量轧压（Private name mangling）during runtime)
_object      # obey python coding convention, consider it as private

In [13]: class A(object):
    ...:        def __init__(self):
    ...:               self.__private()
    ...:               self.public()
    ...:        def _private(self):             # _
    ...:               print ('A.__private()')
    ...:        def public(self):
    ...:               print ('A.public()')
    ...: class B(A):
    ...:        def private(self):
    ...:               print ('B.__private()')
    ...:        def public(self):
    ...:               print ('B.public()')
    ...: b = B()
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-13-542aaca0c968> in <module>
     12        def public(self):
     13               print ('B.public()')
---> 14 b = B()

<ipython-input-13-542aaca0c968> in __init__(self)
      1 class A(object):
      2        def __init__(self):
----> 3               self.__private()
      4               self.public()
      5        def _private(self):

AttributeError: 'B' object has no attribute '_A__private'
私有变量会在代码生成之前被转换为长格式（变为公有）。转换机制是这样的：在变量前端插入类名，
再在前端加入一个下划线字符。这就是所谓的私有变量轧压（Private name mangling）。
如类 A里的__private标识符将被转换为_A__private，

In [14]: class A(object):
    ...:        def __init__(self):
    ...:               self.__private()
    ...:               self.public()
    ...:        def __private(self):
    ...:               print ('A.__private()')
    ...:        def _public(self):
    ...:               print ('A.public()')
    ...: class B(A):
    ...:        def private(self):
    ...:               print ('B.__private()')
    ...:        def public(self):
    ...:               print ('B.public()')
    ...: b = B()
A.__private()
B.public()

In [15]: b._public()   #  "单下划线" 开始的类对象和子类对象自己能访问到这些变量
A.public()

In [16]: b.__private()
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-16-e63e1c980c04> in <module>
----> 1 b.__private()

AttributeError: 'B' object has no attribute '__private'

In [17]: A.__private()
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-17-55946f8ae125> in <module>
----> 1 A.__private()

AttributeError: type object 'A' has no attribute '__private'

In [20]: b._A__private()   # "双下划线" 开始的是私有成员，意思是只有类对象自己能访问，连子类对象也不能访问到这个数据
A.__private()              # 前面加上“单下划线”+类名,eg：_Class__object）机制就可以访问private了

```

### 17 yeild iterator
**Iterator  Iterable**
```python
# In [27]: Iterator.__abstractmethods__
# Out[27]: frozenset({'__next__'})


# In [29]: Iterable.__abstractmethods__
# Out[29]: frozenset({'__iter__'})

# In [1]: l = [1,2,3,4,5]

# In [3]: reversed(l)
# Out[3]: <list_reverseiterator at 0x29d9d6aa390>

# In [4]: iter(l)
# Out[4]: <list_iterator at 0x29d9d74d860>

# Iterable 如 list string      /Iterator 如 l = list 中的 l 有__next__()方法
# Iterable 实现了__iter__ 方法  /Iterator 实现了__next__方法
# 生成器 都是迭代器

import requests
from collections import Iterator, Iterable


class WeatherIterator(Iterator):
    def __init__(self, cities):
        self.cities = cities
        self.index = 0

    def getWeather(self, city):
        r = requests.get(u'http://wthrcdn.etouch.cn/weather_mini?city=' + city)
        data = r.json()['data']['forecast'][0]
        return '%s: %s, %s' % (city, data['low'], data['high'])

    def __next__(self):
        if self.index == len(self.cities):
            raise StopIteration
        city = self.cities[self.index]
        self.index += 1
        return self.getWeather(city)


class WeathrerIterable(Iterable):  
    def __init__(self, cities):
        self.cities = cities

    def __iter__(self):
        return WeatherIterator(self.cities)

for x in WeathrerIterable([u'北京', u'上海', u'西安', u'齐齐哈尔', u'厦门', u'广州', u'香港', u'深圳', u'呼和浩特']):
    print(x)




In [11]: dir(l)   # list 实现的方法    index  reversed  __iter__
Out[13]:
Out[11]:
['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', 
'__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__',
 '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__',
  '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__',
   '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert',
    'pop', 'remove', 'reverse', 'sort']


In [13]: dir(ll)   # ll = iter(list)   Iterator 实现的方法   __iter__  __next__
Out[13]:
['__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', 
'__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__length_hint__', '__lt__',
 '__ne__', '__new__', '__next__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__setstate__',
  '__sizeof__', '__str__', '__subclasshook__']


In [22]: def fun():
    ...:     for i in range(20):
    ...:         x = yield i  #表达式(yield i)的返回值将赋值给x
    ...:         print(x)
    ...:         print('good', x)
    ...:
    ...: a = fun()

In [23]: dir(a)   # 生成器实现的方法   __iter__  __next__
Out[23]:
['__class__', '__del__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', 
'__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', 
'__lt__', '__name__', '__ne__', '__new__', '__next__', '__qualname__', '__reduce__', '__reduce_ex__',
 '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'close', 'gi_code', 'gi_frame', 
 'gi_running', 'gi_yieldfrom', 'send', 'throw']
 
 print(a.__iter__() is a)   # true



In [6]: l = range(20)

In [7]: l
Out[7]: range(0, 20)

In [8]: print(l)
range(0, 20)

In [9]: for x in l:print(x)
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19


In [11]: l.__str__
Out[11]: <method-wrapper '__str__' of range object at 0x0000029D9D4B1FC0>

In [12]: l.__str__()
Out[12]: 'range(0, 20)'

In [13]: print(l.__str__())
range(0, 20)

In [14]: print(l.__repr__())
range(0, 20)

In [15]: t = iter(l)

In [17]: from itertools import islice

In [18]: for x in islice(t, 5,10):
    ...:     print(x)
5 6 7 8 9

In [20]: for x in t:
    ...:     print(x)
10 11 12 13 14 15 16 17 18 19  # 从10开始



In [21]: from random  import randint

In [22]: chinese = [randint(60, 100) for x in range(10)]

In [23]: math = [randint(60, 100) for x in range(10)]

In [24]: english = [randint(60, 100) for x in range(10)]

In [26]: for ch, m, en in zip(chinese, math, english):
    ...:     print(ch + m + en)
229 261 216 189 256 237 212 242 246 237



In [27]: from itertools import chain

In [30]: for x in chain(chinese, math, english):
    ...:     print(x)
61 86 69 61 94 93 74 86 70 91 98 88 61 64 62 70 66 74 80 84 70 87 86 64 100 74 72 82 96 62



set(dir(p1)) – set(dir(p2))
```

**反向迭代  __reversed__**
```python
class FloatRange:
    def __init__(self, start, end, step=0.1):
        self.start = start
        self.end = end
        self.step = step

    
    # 正向迭代
    def __iter__(self):

        t = self.start
        # while t <= self.end:
        while round(t, 2) <= round(self.end, 2):
            yield t
            t += self.step
    
    
    # 反向迭代
    def __reversed__(self):
        t = self.end
        # while t >= self.start:
        while round(t, 2) >= round(self.start, 2):
            yield t
            t -= self.step


if __name__ == "__main__":
    for x in FloatRange(1.0, 4.0, 0.5):
        print(x)
    print("")
    for x in reversed(FloatRange(1.0, 4.0, 0.5)):  # __reversed__ 方法的调用?
        print(x)

```
**使用生成器函数实现可迭代对象**
```python
class PrimeNumbers:
    def __init__(self, start, end):
        self.start = start
        self.end = end

    
    def isPrimeNum(self, k):
        if k < 2:
            return False

        for i in range(2, k):
            if k % i == 0:
                return False
        return True

    
    def __iter__(self):
        for k in range(self.start, self.end + 1):
            if self.isPrimeNum(k):
                yield k     # 由于yield 有__next__方法，可当做Iterator，从而通过生成器函数yield实现 Iterable(对象)

if __name__ == "__main__":
    for x in PrimeNumbers(1, 100):
        print(x)


#2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97
```

### 19 callback



### 20 list sort sorted

**sort 无返回值，将原列表改变    sorted 返回一个序后的新列表，原列表未改变**
```python

In [51]: d = ['j', 'd', 'f', 'l', 'a']

In [52]: d.sort()

In [53]: type(d.sort)
Out[53]: builtin_function_or_method

In [54]: type(d.sort())  # sort 无返回值  但是会对列表的对象进行排序
Out[54]: NoneType

In [55]: res = "".join(d)  # join 中必须是iterable

In [56]: print(res)
adfjl



In [1]: list = [0,-1,3,-10,5,9]

In [2]: list.sort()

In [3]: list
Out[3]: [-10, -1, 0, 3, 5, 9]



In [4]: list1 = [0,-1,3,-10,5,9]

In [6]: res = sorted(list1,reverse=False)

In [7]: res
Out[7]: [-10, -1, 0, 3, 5, 9]

In [9]: list1
Out[9]: [0, -1, 3, -10, 5, 9]
```
### 21 re正则表达式
1、match        
	
	re.match(pattern, string[, flags])  

从**首字母**开始开始匹配，string如果包含pattern子串，则匹配成功，返回Match对象，失败则返回None，若要完全匹配，pattern要以$结尾。

2、search

        re.search(pattern, string[, flags])  
若string中包含pattern子串，则返回Match对象，否则返回None，注意，如果string中存在多个pattern子串，**只返回第一个**。

3、findall

        re.findall(pattern, string[, flags])  
返回string中所有与pattern相匹配的**全部子串**，返回形式为**列表**，**不需要group()**。

4、finditer

        re.finditer(pattern, string[, flags])  
返回string中所有与pattern相匹配的**全部子串**，返回形式为**迭代器**。


若匹配成功，match()/search()返回的是Match对象，finditer()返回的也是Match对象的迭代器，获取匹配结果需要**调用Match对象的group()、groups或group(index)方法**。
group()、groups()与group(index)的区别，如下所示：

```python
>>> import re  
>>> s = '23432werwre2342werwrew'  
>>> p = r'(\d*)([a-zA-Z]*)'  
>>> m = re.match(p,s)  
>>> m.group()  
'23432werwre'  
>>> m.group(0)  
'23432werwre'  
>>> m.group(1)  
'23432'  
>>> m.group(2)  
'werwre'  
>>> m.groups()  
('23432', 'werwre')  
>>> m = re.findall(p,s)  
>>> m  
[('23432', 'werwre'), ('2342', 'werwrew'), ('', '')]  
>>> p=r'(\d+)'  
>>> m=re.match(p,s)  
>>> m.group()  
'23432'  
>>> m.group(0)  
'23432'  
>>> m.group(1)  
'23432'  
>>> m.groups()  
('23432',)  
>>> m=re.findall(p,s)  
>>> m  
['23432', '2342']  
```

综上：

group()：母串中与模式pattern匹配的子串；

group(0)：结果与group()一样；

groups()：所有group组成的一个元组，group(1)是与patttern中第一个group匹配成功的子串，group(2)是第二个，

依次类推，如果index超了边界，抛出IndexError；

findall()：返回的就是所有groups的数组，就是group组成的元组的数组，母串中的这一撮组成一个元组，那一措组成一个元组，

这些元组共同构成一个list，就是findall()的返回结果。另，如果groups是只有一个元素的元组，findall的返回结果是子串的list，而不是元组的list了。


### 22 python垃圾回收机制

[python垃圾回收机制](https://www.cnblogs.com/Xjng/p/5128269.html)

### 23 lambda

```python
In [1]: a = ["ab", "cd", "", "", "hg",""]

In [3]: res = list(map(lambda x:"fill value" if x=="" else x, a))

In [4]: res
Out[4]: ['ab', 'cd', 'fill value', 'fill value', 'hg', 'fill value']
```


### 24 python传参数是传址 引用
```


```
### 25 if not

if ture  才会执行
[if not ](https://www.cnblogs.com/chenya/p/4218761.html)


### 26 name main
```
__name__就是标识模块的名字的一个系统变量。这里分两种情况：假如当前模块是主模块（也就是调用其他模块的模块），
那么此模块名字就是__main__，通过if判断这样就可以执行“__mian__:”后面的主函数内容；

假如此模块是被import的，则此模块名字为文件名字（不加后面的.py），通过if判断这样就会跳过“__mian__:”后面的内容。
```
### 27 classmethod staticmethod
```python
class A(object):
    def foo(self, x): 
        print("executing foo(%s,%s)" % (self, x))
        print('self:', self)
    @classmethod
    def class_foo(cls, x):
        print("executing class_foo(%s,%s)" % (cls, x))
        print('cls:', cls)
    @staticmethod  # 有@staticmethod (x)(self, x)效果一样
    def static_foo(x):    # self cls 粉色显示  三个x白色显示
        print("executing static_foo(%s)" % x)
a = A()
m = "ML"
a.foo(m)
a.class_foo(m)
a.static_foo(m)

>>>
executing foo(<__main__.A object at 0x000001C7D0614588>,ML)
self: <__main__.A object at 0x000001C7D0614588>
executing class_foo(<class '__main__.A'>,ML)
cls: <class '__main__.A'>
executing static_foo(ML)

```
```python
class A(object):
    def foo(self, x):         # x白色显示
        print("executing foo(%s,%s)" % (self, x))
        print('self:', self)
    # @classmethod 
    def class_foo(cls, x):    # x白色显示
        print("executing class_foo(%s,%s)" % (cls, x))
        print('cls:', cls)
    # @staticmethod  不加@staticmethod 的话需要(self, x)
    def static_foo(x):        # self cls 粉色显示  此处x粉色显示，默认传入自己 所以后面报错
        print("executing static_foo(%s)" % x)
a = A()
m = "ML"
a.foo(m)
a.class_foo(m)
a.static_foo(m)

>>>
executing foo(<__main__.A object at 0x0000029EC0C8B8D0>,ML)
self: <__main__.A object at 0x0000029EC0C8B8D0>
executing class_foo(<__main__.A object at 0x0000029EC0C8B8D0>,ML)
cls: <__main__.A object at 0x0000029EC0C8B8D0>
Traceback (most recent call last):
  File "F:/hw_data/code/e.py", line 23, in <module>
    a.static_foo(m)
TypeError: static_foo() takes 1 positional argument but 2 were given
```

### 28 abstract class
```
抽象类，无法实例化任何对象。请使用它的子类
```

### 29 函数参数有冒号 声明后有箭头

- [Python 函数参数有冒号 声明后有-> 箭头](https://www.cnblogs.com/Stitchez/p/10006519.html)

### 30 unittest assert

```
https://www.cnblogs.com/zln1021/p/6964239.html
import unittest


class Assert(unittest.TestCase):
    def f(self):
        self.assertEqual(type("243"), str, "断言内容完全一样才可以")  # pass
        self.assertEqual("243", "243", "断言内容完全一样才可以")  # pass
        # self.assertEqual("243", "2413", "断言内容完全一样才可以")
        self.assertEqual("243", str, "断言内容完全一样才可以")


x = Assert()
x.f()
```
### 31 双下划线开头的函数和变量 内置方法 魔法方法

[双下划线开头的函数和变量 内置方法 魔法方法](https://www.cnblogs.com/nkwy2012/p/6264031.html)

### 32 hook method

```
# hook是一个编程机制，与语言无关。这里给个python的简单例子，帮助大家理解：

import time

class LazyPerson(object):
    def __init__(self, name):
        self.name = name
        self.watch_tv_func = None
        self.have_dinner_func = None

    def get_up(self):
        print("%s get up at:%s" % (self.name, time.time()))

    def go_to_sleep(self):
        print("%s go to sleep at:%s" % (self.name, time.time()))

    def register_tv_hook(self, watch_tv_func):
        self.watch_tv_func = watch_tv_func

    def register_dinner_hook(self, have_dinner_func):
        self.have_dinner_func = have_dinner_func

    def enjoy_a_lazy_day(self):

        # get up
        self.get_up()
        time.sleep(3)
        # watch tv
        # check the watch_tv_func(hooked or unhooked)
        # hooked
        if self.watch_tv_func is not None:
            self.watch_tv_func(self.name)
        # unhooked
        else:
            print("no tv to watch")
        time.sleep(3)
        # have dinner
        # check the have_dinner_func(hooked or unhooked)
        # hooked
        if self.have_dinner_func is not None:
            self.have_dinner_func(self.name)
        # unhooked
        else:
            print("nothing to eat at dinner")
        time.sleep(3)
        self.go_to_sleep()

def watch_daydayup(name):
    print("%s : The program ---day day up--- is funny!!!" % name)

def watch_happyfamily(name):
    print("%s : The program ---happy family--- is boring!!!" % name)

def eat_meat(name):
    print("%s : The meat is nice!!!" % name)


def eat_hamburger(name):
    print("%s : The hamburger is not so bad!!!" % name)


if __name__ == "__main__":
    lazy_tom = LazyPerson("Tom")
    lazy_jerry = LazyPerson("Jerry")
    # register hook
    lazy_tom.register_tv_hook(watch_daydayup)   # 
    lazy_tom.register_dinner_hook(eat_meat)
    lazy_jerry.register_tv_hook(watch_happyfamily)
    lazy_jerry.register_dinner_hook(eat_hamburger)
    # enjoy a day
    lazy_tom.enjoy_a_lazy_day()
    lazy_jerry.enjoy_a_lazy_day()


#代码运行结果：

Tom get up at:1509246940.32
Tom : The program ---day day up--- is funny!!!
Tom : The meat is nice!!!
Tom go to sleep at:1509246949.34
Jerry get up at:1509246949.34
Jerry : The program ---happy family--- is boring!!!
Jerry : The hamburger is not so bad!!!
Jerry go to sleep at:1509246958.37
```
### 33 last,now=now,max(last+num,now)

```python3
def rob( nums):
    """
    :type nums: List[int]
    :rtype: int
    """
    last, now = 0, 0
    for num in nums:
        last, now = now, max(last+num, now)            #  注意 和下面的rob2效果一样
	# 不等于
	# last = now
        # now = max(last+num, now)
        print('last:  '+str(last)+'   now:   '+str(now))
    return now


def rob2(houses):
    last, now = 0, 0
    for house in houses:
        tmp = now
        now = max(last + house, now)
        last = tmp
        print('last:  '+str(last)+'   now:   '+str(now))
    return now

rob([1,2,3,1])
print('\n\n\n')
rob2([1,2,3,1])

# 思维定势
# ------------------------
last:  0   now:   1
last:  1   now:   2
last:  2   now:   4
last:  4   now:   4



last:  0   now:   1
last:  1   now:   2
last:  2   now:   4
last:  4   now:   4
```
### 34 reduce

[https://www.cnblogs.com/XXCXY/p/5180245.html](https://www.cnblogs.com/XXCXY/p/5180245.html)

### 35 Daemon

[Daemon](https://github.com/jumper2014/PyCodeComplete/blob/master/docs/Python%E5%AE%9E%E8%B7%B54-%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B.md)

```
守护线程(后台线程)
在后台运行，并且不和用户直接交互

要点：线程可以通过setDaemon(True)被设置为守护线程，当仅有守护线程运行时，主程序才能退出。
主线程活着的时候，守护线程才会存活。主线程结束后，守护线程会自动被杀死结束运行。
主线程需等所有非守护线程（非后台）退出后才会退出，如果想要结束非守护线程，我们必须手动找出非守护线程将其杀死。

总结
如果需要子线程随主线程一同退出-设置它为守护线程。
如果需要子线程运行结束后，主线程才能退出-设置子线程为非守护线程。
```

### TODO
```
i = 5

def f(arg=i):
    print(arg)

i = 6
f()  # 5
```

### 

