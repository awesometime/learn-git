 * [Python基础知识](#python基础知识)
      * [36 property setter](#36-property-setter)
      * [22 python内存分配垃圾回收机制](#22-python内存分配垃圾回收机制)
      * [37 可迭代对象迭代器生成器](#37-可迭代对象迭代器生成器)
      
### 36 property setter
```python3
class Node():
    def __init__(self, data=None):
        self._data = data
        self._left, self._right = None, None

    def __str__(self):
        return 'Node:<data:%s>, <left:%s>, <right:%s>' % (
            str(self._data), str(self._left), str(self._right))

    @property
    def data(self):
        return self._data

    @data.setter
    def data(self, value):
        self._data = value

    @property
    def left(self):
        return self._left

    @left.setter
    def left(self, value):
        self._left = value

    @property
    def right(self):
        return self._right

    @right.setter
    def right(self, value):
        self._right = value
```
### 22 python内存分配垃圾回收机制

[python垃圾回收机制](https://www.cnblogs.com/Xjng/p/5128269.html)

[Python的内存管理以及垃圾回收](https://blog.csdn.net/onlyanyz/article/details/45605773)

[Python的内存管理](https://www.cnblogs.com/vamei/p/3232088.html)

[引用计数为主， 标记清除、分代回收](https://segmentfault.com/a/1190000016078708)

> 垃圾回收机制
```
Python的垃圾回收机制以引用计数为主， 标记清除、分代回收为辅。

1 引用计数
Python在内部维护了针对每一个对象的引用计数，
当一个对象创建或者被引用时，其引用计数将加1，当一个对象被销毁或作用域失效时， 其引用计数将减1。只有对象的引用计数为0时，
这个对象将会被回收。引用计数的优点：简单、具有实时性。
缺点：对象循环引用时将永远不会被销毁。对于对象循环引用的状况

2 标记清除 
Python使用标记清除来解决，Python在内部实现了一个循环检测器， 不停的检测对象是否存在循环引用，如果两个对象互相循环引用
并且不包含其他第三者对象时， 其将会被收回。在Python参考手册中有写道：当一个对象无法获取时， 那么这个对象有可能被当成垃
圾销毁了。

3 分代回收 
Python将所有对象分成了三代， 对象存活时间越长就越晚被回收， 反之则越早被回收。
```

> 内存管理：内存池机制
```
http://images.cnitblog.com/blog/333250/201410/110017426714010.x-png

Python使用了内存池机制来管理内存，其内存以金字塔的形式对内存功能进行划分，
-1、-2层主要用于对操作系统进行操作， 
0层中是C的malloc,、free等等内存分配和释放函数。
1、2层是一个内存池， 当对象小于265K时将直接由这片内存池进行分配内存，否则将调用第0层中的C函数来分配内存，当小于265K的对象
被销毁时， 其内存也不会被销毁， 只是返回给了内存池以便二次利用。2层是对Python对象进行操作。


Python的内存机制以金字塔行，-1，-2层主要有操作系统进行操作，
第0层是C中的malloc，free等内存分配和释放函数进行操作；
第1层和第2层是内存池，有Python的接口函数PyMem_Malloc函数实现，当对象小于256K时有该层直接分配内存；
第3层是最上层，也就是我们对Python对象的直接操作；

在 C 中如果频繁的调用 malloc 与 free 时,是会产生性能问题的.再加上频繁的分配与释放小块的内存会产生内存碎片. 
Python 在这里主要干的工作有:
如果请求分配的内存在1~256字节之间就使用自己的内存管理系统,否则直接使用 malloc.
这里还是会调用 malloc 分配内存,但每次会分配一块大小为256k的大块内存.
经由内存池登记的内存到最后还是会回收到内存池,并不会调用 C 的 free 释放掉.以便下次使用
```
### 37 可迭代对象迭代器生成器
[可迭代、迭代器、生成器](https://juejin.im/post/5b3391a0518825748b56b42c)
