### 最快的方法

```python3
def GetUglyNumber_Solution(index):
    if index < 7:
        return index
    res = [1] * index  # IndexError: list assignment index out of range
    # t2, t3, t5分别为三个队列的指针
    t2, t3, t5 = 0, 0, 0

    for i in range(1, index):
        # 选出三个队列头最小的数res[i]
        res[i] = min(res[t2] * 2, min(res[t3] * 3, res[t5] * 5))
        # 这三个if有可能进入一个或者多个，进入多个是三个队列头最小的数有多个的情况
        if res[i] == res[t2] * 2:
            t2 += 1
        if res[i] == res[t3] * 3:
            t3 += 1
        if res[i] == res[t5] * 5:
            t5 += 1
        print(res)
        print(t2, t3, t5)
        print(res[t2], res[t3], res[t5])
        print()
    return res[index - 1]


import time

start_time = time.time()
print(GetUglyNumber_Solution(10))
end_time = time.time()
print(end_time - start_time)


# 通俗易懂的解释：
# 首先从丑数的定义我们知道，一个丑数的因子只有2,3,5，那么丑数p = 2 ^ x * 3 ^ y * 5 ^ z，换句话说
# 一个丑数一定由另一个丑数乘以2或者乘以3或者乘以5得到，那么我们从1开始乘以2,3,5，就得到2,3,5三个丑数，
# 在从这三个丑数出发乘以2,3,5就得到4，6,10,6，9,15,10,15,25九个丑数，我们发现这种方法会得到重复的丑数，
# 而且我们题目要求第N个丑数，这样的方法得到的丑数也是无序的。那么我们可以维护三个队列：
# （1）丑数数组： 1
# 乘以2的队列：2
# 乘以3的队列：3
# 乘以5的队列：5
# 选择三个队列头最小的数2加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；
# （2）丑数数组：1,2
# 乘以2的队列：4
# 乘以3的队列：3，6
# 乘以5的队列：5，10
# 选择三个队列头最小的数3加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；
# （3）丑数数组：1,2,3
# 乘以2的队列：4,6
# 乘以3的队列：6,9
# 乘以5的队列：5,10,15
# 选择三个队列头里最小的数4加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；
# （4）丑数数组：1,2,3,4
# 乘以2的队列：6，8
# 乘以3的队列：6,9,12
# 乘以5的队列：5,10,15,20
# 选择三个队列头里最小的数5加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；
# （5）丑数数组：1,2,3,4,5
# 乘以2的队列：6,8,10，
# 乘以3的队列：6,9,12,15
# 乘以5的队列：10,15,20,25
# 选择三个队列头里最小的数6加入丑数数组，但我们发现，有两个队列头都为6，所以我们弹出两个队列头，同时将12,18,30放入三个队列；
# ……………………
# 疑问：
# 1.为什么分三个队列？
# 丑数数组里的数一定是有序的，因为我们是从丑数数组里的数乘以2,3,5选出的最小数，一定比以前未乘以2,3,5大，同时对于三个队列内部，
# 按先后顺序乘以2,3,5分别放入，所以同一个队列内部也是有序的；
# 2.为什么比较三个队列头部最小的数放入丑数数组？
# 因为三个队列是有序的，所以取出三个头中最小的，等同于找到了三个队列所有数中最小的。
# 实现思路：
# 我们没有必要维护三个队列，只需要记录三个指针显示到达哪一步；“|”表示指针,arr表示丑数数组；
# （1）1
# |2
# |3
# |5
# 目前指针指向0,0,0，队列头arr[0] * 2 = 2,  arr[0] * 3 = 3,  arr[0] * 5 = 5
# （2）1 2
# 2 |4
# |3 6
# |5 10
# 目前指针指向1,0,0，队列头arr[1] * 2 = 4,  arr[0] * 3 = 3, arr[0] * 5 = 5
# （3）1 2 3
# 2| 4 6
# 3 |6 9
# |5 10 15
# 目前指针指向1,1,0，队列头arr[1] * 2 = 4,  arr[1] * 3 = 6, arr[0] * 5 = 5
# ………………
```


###  自己的方法

```python3
# 前20个丑数为：
#  1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, 25, 27, 30, 32, 36。
# 1 1  2  3     5
# 2          4     6        10
# 3 	                 9          15
# 4 		          8         12              20
# 5 		                                            25
# 6                                         18                  30
# 8                                     16          24                                  40
# 9                                                         27									45
# 10 														                                        50
# 12 			                                                        36                                 60
# 15 																	                                        75
# 16 																32							  48		          80

# 思路
# 1235初始化,然后从2开始对每个数进行乘2乘3乘5操作,由于可能与之前已有的数重复,所以去重之后排序再加到列表
# 对2之后的每个 重复这个步骤k次 保证前k个的正确性

def GetUglyNumber_Solution(index):
    #rst_pre = [1, 2, 3, 4, 5, 6]
    #if index < 7:
        #return rst_pre[:index]   # 返回前几个
    
	if index < 7:
        return index   # 返回第几个
	
    rst = [1, 2, 3, 5]
    for i in range(1, index):
        cur = [rst[i] * 2, rst[i] * 3, rst[i] * 5]
        cur_drop_duplicate = [i for i in cur if i not in rst]
        rst += cur_drop_duplicate
        # sorted(rst)  # 原rst并不改变
        rst = sorted(rst)  # 所以必须返回 原rst并不改变
        # rst.sort()       # 也行

    return rst[index-1]    # 返回第几个  注意不能是 rst[-1]
    # return rst[:index]   # 返回前几个


import time
start_time = time.time()
print(GetUglyNumber_Solution(1400))
end_time = time.time()
print(end_time-start_time)  # 0.3123326301574707

# list 的 sort 方法返回的是对已经存在的列表进行操作，
# 而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作
```
### 脏法tricky

```python3
def GetUglyNumber_Solution(self, index):
        res=[2**i*3**j*5**k  for i in range(30)  for j in range(20)   for k in range(15)]
        res.sort()
        return res[index-1] if index else 0

#如果太大，时间复杂度可能不满足。如果太小，有些数就会漏掉。看你把控，能accept就好。
#例如，对于我挑的30、20、15这三个数。是不可能出现2^31的，但是(2^29) *(5^1)反而大于2^31，
#所以2^31就会被漏掉。如果题目正好要找的是2^31，那么实际返回的会是比它大的数。
#这个时候就要再增加这三个数了
```


### 最慢的方法
```
# 遍历每个整数求第k个丑数，从1开始遍历，如果是丑数则count++，直到count=k为止
# 首先除2，直到不能整除为止，然后除5到不能整除为止，然后除3直到不能整除为止。
# 最终判断剩余的数字是否为1，如果是1则为丑数，否则不是丑数。
```
