https://www.cnblogs.com/smile233/p/8511546.html

### 位操作


- step1: 计算进位 `按位与 左移一位` 
- step2: 直接相加算非进位位 `异或`
- step3: 循环截止条件：n1&n2没有进位位
         如果有，需要重复step1、step2

具体：

首先看十进制是如何做的： 5+7=12，三步走

第一步：相加各位的值，不算进位，得到2。

第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。

第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。


　　同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111
  
第一步：相加各位的值，`不算进位`，得到010，`二进制每位相加就相当于各位做异或操作`，101^111。

第二步：`计算进位值`，得到1010，相当于`各位做与操作`得到101，`再向左移一位`得到1010，(101&111)<<1。

第三步：重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&1010)<<1。 
       继续重复上述两步：1000^100 = 1100，
       `进位值为0，跳出循环`，1100为最终结果。
   


```
# 帮助理解
def Add(num1, num2):
循环
    temp1 = num1 ^ num2
    temp2 = (num1 & num2) << 1
    csum = temp1 + temp2
    return csum
```
```python3
class Solution:
    def Add(self, num1, num2):
        while num2 != 0:
            temp = num1 ^ num2
            num2 = (num1 & num2) << 1
	    # python3中-3表示成-0b11,需要通过(-3) & 0xFFFFFFFF 求得-3的正确表示,也就是补码,不然-0b11怎么运算
            num1 = temp & 0xFFFFFFFF
        
        return num1 if num1 >> 31 == 0 else num1 - 4294967296     # 2的32次4294967296
		
class Solution: 
    def Add(self, a, b):           
        while(b): 
            a,b = (a^b) & 0xFFFFFFFF,((a&b)<<1) & 0xFFFFFFFF
        
	return a if a<=0x7FFFFFFF else ~(a^0xFFFFFFFF)
 
# 原文：https://blog.csdn.net/lrs1353281004/article/details/87192205 
# [深度剖析凭什么python中整型不会溢出](https://segmentfault.com/a/1190000015284473)

```

```
比如-13， -11 最后一步 num1 = 0b11111111111111111111111111101000
print(int('0b11111111111111111111111111101000',2))  4294967272-4294967296=-24
print(-24 & 0xFFFFFFFF)  # 4294967272
print(bin(4294967272))   # 0b11111111111111111111111111101000
-24 的补码0b11111111111111111111111111101000 
也就是0b11111111111111111111111111101000 表示成负数是-24 表示成正数是4294967272
什么时候表示成负数  第一个1代表符号位, 什么时候表示成负数，没有符号位
胡扯。。。。。
只讨论32位大的数的计算（实际大于32位也满足）
32个1能表示的最大正整数是4294967295,如果一个数大于4294967295,肯定表示是负数
32个1能表示的最大负整数是。。。。
```

```	   
>>> a = -1
>>> a &=0xffffffff
>>> a
4294967295L

一个负数n=-3，它的二进制
原码为：10000000 00000000 00000000 00000011（首位为符号位），
反码为：11111111 11111111 11111111 11111100（符号位不变），
补码为：11111111 11111111 11111111 11111101.
a = bin(-3)
print(a)
# -0b11
b = bin(-3 & 0xffffffff)
print(b)
# 0b11111111111111111111111111111101
python没有无符号右移操作，所以需要越界检查
python没有unsigned int类型，为什么 负数& 0xFFFFFFFF 返回的数就成一个正数


s = -3 & 0xFFFFFFFF
print(s)	
# 4294967281
~n = -(n+1)

```
扩展
```
不使用新的变量，交换两个变量的值

①基于加减法

1 a = a + b;
2 b = a - b;
3 a = a - b;
②基于异或运算

1 a = a ^ b;
2 b = a ^ b;
3 a = a ^ b;
```
