### 位操作

- step1: 按位与是查看两个数哪些二进制位都为1，这些都是进位位，结果需左移一位，表示进位后的结果
- step2: 异或是查看两个数哪些二进制位只有一个为1，这些是非进位位，可以直接加、减，结果表示非进位位进行加
         操作后的结果
- step3: n1&n2是查看有没有进位位了，如果有，需要重复step1、step2；如果没有，保留n1、n2上二进制为1的部分，
         用或将之合为一个数，即为最后结果
```
# 帮助理解
def Add(num1, num2):
    temp1 = num1 ^ num2
    temp2 = (num1 & num2) << 1
    csum = temp1 + temp2
    return csum
```
```python3
class Solution:
    def Add(self, num1, num2):
        while num2 != 0:
            temp = num1 ^ num2
            num2 = (num1 & num2) << 1
	    # python3中-3表示成-0b11,需要通过(-3) & 0xFFFFFFFF 求得-3的正确表示,也就是补码,不然-0b11怎么运算
            num1 = temp & 0xFFFFFFFF
        
        return num1 if num1 >> 31 == 0 else num1 - 4294967296     # 2的32次4294967296
		
class Solution: 
    def Add(self, a, b):           
        while(b): 
            a,b = (a^b) & 0xFFFFFFFF,((a&b)<<1) & 0xFFFFFFFF
        
	return a if a<=0x7FFFFFFF else ~(a^0xFFFFFFFF)
 
# 原文：https://blog.csdn.net/lrs1353281004/article/details/87192205 
# [深度剖析凭什么python中整型不会溢出](https://segmentfault.com/a/1190000015284473)

```

```
比如-13， -11 最后一步 num1 = 0b11111111111111111111111111101000
print(int('0b11111111111111111111111111101000',2))  4294967272-4294967296=-24
print(-24 & 0xFFFFFFFF)  # 4294967272
print(bin(4294967272))   # 0b11111111111111111111111111101000
-24 的补码0b11111111111111111111111111101000 
也就是0b11111111111111111111111111101000 表示成负数是-24 表示成正数是4294967272
什么时候表示成负数  第一个1代表符号位, 什么时候表示成负数，没有符号位
胡扯。。。。。
只讨论32位大的数的计算（实际大于32位也满足）
32个1能表示的最大正整数是4294967295,如果一个数大于4294967295,肯定表示是负数
32个1能表示的最大负整数是。。。。
```

```	   
>>> a = -1
>>> a &=0xffffffff
>>> a
4294967295L

一个负数n=-3，它的二进制
原码为：10000000 00000000 00000000 00000011（首位为符号位），
反码为：11111111 11111111 11111111 11111100（符号位不变），
补码为：11111111 11111111 11111111 11111101.
a = bin(-3)
print(a)
# -0b11
b = bin(-3 & 0xffffffff)
print(b)
# 0b11111111111111111111111111111101
python没有无符号右移操作，所以需要越界检查
python没有unsigned int类型，为什么 负数& 0xFFFFFFFF 返回的数就成一个正数


s = -3 & 0xFFFFFFFF
print(s)	
# 4294967281
~n = -(n+1)

```
